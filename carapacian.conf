upstream app_server {
    # Fail_timeout=0 means we always retry an upstream even if it failed
    # to return a good HTTP response

    # for UNIX domain socket setups
    server unix:/tmp/gunicorn.sock fail_timeout=0;

    # For a TCP configuration
    # server 192.168.0.7:8000 fail_timeout=0;
}

server {
    # XXX Test this. Make sure we get a 444 if we use an incorrect
    # host name.
    #
    # If no Host match, close the connection to prevent host
    # spoofing
    # 
    # The default_server parameter, if present, will cause the
    # server to become the default server for the specified
    # address:port pair. If none of the directives have the
    # default_server parameter then the first server with the
    # address:port pair will be the default server for this pair. 
    listen 80 default_server;
    return 444;
}

server {
    # Use 'listen 80 deferred;' for Linux. `deferred` instructs to
    # use a deferred accept() (the TCP_DEFER_ACCEPT socket option)
    # on Linux. 
    listen 80 deferred;

    # Set the maximum allowed size of the client request body. If
    # the size in a request exceeds the configured value, the 413
    # (Request Entity Too Large) error is returned to the client.
    # Please be aware that browsers cannot correctly display this
    # error. Setting size to 0 disables checking of client request
    # body size. XXX Experiment with this to see if we should bring
    # this down a bit.
    client_max_body_size 4G;

    # Set the correct host(s) for your site
    server_name carapacian.com www.carapacian.com;

    # Limits the maximum time during which requests can be processed
    # through one keep-alive connection. After this time is reached,
    # the connection is closed following the subsequent request
    # processing. 
    keepalive_timeout 5;

    # Path for static files. XXX Note that this seems pointless at
    # the moment other that to force try_files to fail.
    # root /path/to/app/current/public;

    location / {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header Host $http_host;
      # we don't want nginx trying to do something clever with
      # redirects, we set the Host: header above already.
      proxy_redirect off;
      proxy_pass http://app_server;
    }
}
