upstream app_server {
    # Fail_timeout=0 means we always retry an upstream even if it failed
    # to return a good HTTP response

    # for UNIX domain socket setups
    server unix:/tmp/gunicorn.sock fail_timeout=0;

    # For a TCP configuration
    # server 192.168.0.7:8000 fail_timeout=0;
}

upstream tmp_port80_app_server {
    # Fail_timeout=0 means we always retry an upstream even if it failed
    # to return a good HTTP response

    # XXX For debugging; remove
    #proxy_set_header Sub $subdomain;


    # for UNIX domain socket setups
    #server unix:/tmp/gunicorn.sock fail_timeout=0;

    # NOTE:0eaac18d This doesn't work because $subdomain is interpreted as a
    # literal.
    server unix:/run/carapacian.com/$subdomain.sock;

    # For a TCP configuration
    # server 192.168.0.7:8000 fail_timeout=0;
}

server {
    listen 443 ssl;

    ssl_certificate /etc/ssl/carapacian_com_chain.crt;

    ssl_certificate_key /etc/ssl/carapacian_com.key;

    # TODO We will uncomment this when provide file access via Nginx
    #root /path/to/webroot;

    server_name carapacian.com
    server_name ~^(?<subdomain>.+)\.carapacian\.com$;

    set $socket /run/carapacian.com/$subdomain.sock;

    # Test for the existence of the socket file
	default_type text/html;
    if (!-x $socket){
        return 502 '<strong>Missing socket: <code>$socket</code></strong>\n';
    }

    # Set the maximum allowed size of the client request body. If
    # the size in a request exceeds the configured value, the 413
    # (Request Entity Too Large) error is returned to the client.
    # Please be aware that browsers cannot correctly display this
    # error. Setting size to 0 disables checking of client request
    # body size. XXX Experiment with this to see if we should bring
    # this down a bit.
    client_max_body_size 4G;

    # Limits the maximum time during which requests can be processed
    # through one keep-alive connection. After this time is reached,
    # the connection is closed following the subsequent request
    # processing. 
    keepalive_timeout 5;

    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;
        # we don't want nginx trying to do something clever with
        # redirects, we set the Host: header above already.
        proxy_redirect off;
        location / {
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Host $http_host;

            # we don't want nginx trying to do something clever with
            # redirects, we set the Host: header above already.
            proxy_redirect off;

            proxy_pass http://unix:/run/carapacian.com/$subdomain.sock;
        }
    }
}

# Redirect 80 -> 443
server {
     listen 80 deferred;

    # Remove this so we redirect on any hostname
    #server_name carapacian.com www.carapacian.com;
    server_name carapacian.com
    server_name ~^(?<subdomain>.+)\.carapacian\.com$;

    set $socket /run/carapacian.com/$subdomain.sock;

	default_type text/html;
    if (!-x $socket){
        return 502 '<strong>Missing socket: <code>$socket</code></strong>\n';
    }


    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;

        # we don't want nginx trying to do something clever with
        # redirects, we set the Host: header above already.
        proxy_redirect off;

        # NOTE:0eaac18d This doesn't work. See other NOTE at 0eaac18d.
        # proxy_pass http://tmp_port80_app_server;
        proxy_pass http://unix:/run/carapacian.com/$subdomain.sock;
    }
}

